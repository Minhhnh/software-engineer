# ðŸŒ€ Python Decorators

Decorators provide a powerful way to extend and modify function or method behavior without modifying the actual code.

## Topics Covered

- Basic decorators
- Handling function arguments and return values
- Preserving metadata using `functools.wraps`
- Passing arguments to decorators
- Stacking multiple decorators
- Stateful class-based decorators
- Practical examples: timing, debugging, caching, validation

## Files

| File                                   | Description                                         |
| -------------------------------------- | --------------------------------------------------- |
| `basic_function_decorator.py`          | Intro to decorators with simple wrapper logic       |
| `decorator_with_args_and_return.py`    | Handle arguments and return values                  |
| `functools_wraps_preserve_metadata.py` | Use `functools.wraps` to preserve function identity |
| `decorator_with_arguments.py`          | Create decorators that accept arguments             |
| `nested_decorators.py`                 | Combine multiple decorators on a function           |
| `class_decorator.py`                   | Use a class as a decorator with state tracking      |
| `practical_use_cases.py`               | Real-world decorator examples (timing, logging)     |

## Run Example

```bash
python basic_function_decorator.py
```

ðŸ“˜ Docs: https://realpython.com/primer-on-python-decorators/
